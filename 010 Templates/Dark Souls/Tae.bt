//--------------------------------------
//--- 010 Editor v5.0 Binary Template
//
// File: Dark Souls .TAE (Animation Listing)
// Author: Jed "Nyxojaele" Lang
// Revision: 1
//--------------------------------------
typedef struct
{
    int Offset <format=hex, bgcolor=0xBB8800>;
    if (Offset != 0)
    {
        local int oldPos = FTell();
        FSeek(Offset);
        wstring Text;
        FSeek(oldPos);
    }
} NameStruct <read=ReadNameStruct, bgcolor=0xCC9900>;
wstring ReadNameStruct(NameStruct &name)
{
    if (exists(name.Text))
        return name.Text;
    return "<empty>";
}

typedef struct
{
    int FirstAnimId;
    int LastAnimId;
    int FirstAnimIdOffset <format=hex>;
} AnimGroupStruct;

typedef struct
{
    int AnimId;
    int Offset <format=hex>;
} AnimIdStruct <read=ReadAnimIdStruct>;
string ReadAnimIdStruct(AnimIdStruct& ais)
{
    string ret;
    SPrintf(ret, "%d", ais.AnimId);
    return ret;
}

typedef struct
{
    int Type <comment="0 = Has filename, 1 = No filename">;
    switch (Type)
    {
        case 0:
            int DataOffset <format=hex>;
            NameStruct Name;
            int Unknown1 <format=hex>;
            int Unknown2;
            int Null;
            if (Null != 0)
                Printf("AnimDataStruct.Null != 0 @ 0x%x\n", FTell());
            break;
        case 1:
            int DataOffset <format=hex>;
            int NextFileOffset <format=hex>;
            int LinkedAnimId;
            int Null1;
            int Null2;
            int Null3;
            if (Null1 != 0 || Null2 != 0 || Null3 != 0)
                Printf("AnimDataStruct.Null != 0 @ 0x%x\n", FTell());
            break;
        default:
            Printf("Unknown AnimFile type @ 0x%x\n", FTell());
            break;
    }
} AnimFileStruct <read=ReadAnimFileStruct>;
wstring ReadAnimFileStruct(AnimFileStruct& afs)
{
    wstring ret;
    if (afs.Type == 0)
    {
        //HACK: c5260 has an anomaly of data that I'm assuming is either a bug, or an indication that I'm making an incorrect assumption
        //It has a single entry that defies the normal logic.
        //This is why we have the 0x01 check here.
        string cmp;
        SPrintf(cmp, "%c", 0x01);
        if (afs.Name.Text == cmp)
            ret = "<no text> (0x01)";
        else
            ret = afs.Name.Text;
    }
    else
        ret = "<no text>";
    return ret;
}

typedef struct
{
    if (ReadInt(FTell()) == SomeElementOffset)
        int Offset <format=hex, bgcolor=0xAAAAAA>;
    else
        int Offset <format=hex>;
    local long oldPos = FTell();
    FSeek(Offset);
    float Value;
    FSeek(oldPos);
} ElementStruct <read=ReadElementStruct>;
string ReadElementStruct(ElementStruct& element)
{
    string ret;
    SPrintf(ret, "%f", element.Value);
    return ret;
}

typedef struct
{
    //All values except AnimDataOffset seem to be 0 when AnimFileStruct.Type == 1
    int Unknown1;   //Type?
    int DataArrayOffset <format=hex>;
    int Null1;
    if (Null1 != 0)
        Printf("AnimHeaderStruct.Null1 != 0 @ 0x%x\n", FTell());
    int Null2;
    if (Null2 != 0)
        Printf("AnimHeaderStruct.Null2 != 0 @ 0x%x\n", FTell());
    int DataElementCount;
    int SomeElementOffset <format=hex, comment="Default element of array? Not always in array">;
    int AnimFileOffset <format=hex>;

    local int oldPos = FTell();
    //Data Array
    FSeek(DataArrayOffset);
    if (DataElementCount != 0 && DataArrayOffset != 0)
    {
        struct
        {
            local int i = 0;
            //TODO: Figure out where the count actually comes from!
            //It doesn't look like DataElementCount covers all the data~
            for (i = 0; i < DataElementCount; ++i)
                ElementStruct Element;
        } DataArray;
    }

    //Anim Data
    FSeek(AnimFileOffset);
    AnimFileStruct AnimFile;
    FSeek(oldPos);
} AnimDataStruct <read=ReadAnimDataStruct>;
wstring ReadAnimDataStruct(AnimDataStruct& ads)
{
    wstring ret;
    if (ads.AnimFile.Type == 0)
    {
        //HACK: c5260 has an anomaly of data that I'm assuming is either a bug, or an indication that I'm making an incorrect assumption
        //It has a single entry that defies the normal logic.
        //This is why we have the 0x01 check here.
        string cmp;
        SPrintf(cmp, "%c", 0x01);
        if (ads.AnimFile.Name.Text == cmp)
            ret = "<no text> (0x01)";
        else
            ret = ads.AnimFile.Name.Text;
    }
    else
        ret = "<no text>";
    return ret;
}

struct
{
    byte Signature[4] <bgcolor=0xCCCCCC>;
    int Unknown1 <bgcolor=0x0000FF>;
    int Unknown2 <bgcolor=0x0000FF>;
    int FileSize <format=hex, bgcolor=0xCCCCCC>;
    byte Unknown3[0x44] <bgcolor=0x0000FF>;    //Always the same?
    int AnimIdCount <bgcolor=0xCCCCCC>;
    int AnimIdsOffset <format=hex, bgcolor=0xCCCCCC>;
    int AnimGroupsOffset <format=hex, bgcolor=0xCCCCCC>;
    byte Unknown6[0x4] <bgcolor=0x0000FF>;
    int AnimDataCount <bgcolor=0xCCCCCC>;
    int AnimDataOffset <format=hex, bgcolor=0xCCCCCC>;
    byte Unknown5[0x28] <bgcolor=0x0000FF>;
    int FilenamesOffset <format=hex, bgcolor=0xCCCCCC>;
} Header;

struct
{
    //From here down, we are seeking to our locations
    FSeek(Header.FilenamesOffset);
    NameStruct SkeletonHkxName;
    NameStruct SibName;

    FSeek(Header.AnimIdsOffset);
    struct
    {
        AnimIdStruct AnimId[Header.AnimIdCount] <bgcolor=0xCCCCCC>;
    } AnimIds;

    FSeek(Header.AnimGroupsOffset);
    int AnimGroupCount <bgcolor=0xCCCCCC>;
    int AnimGroupDataOffset <bgcolor=0xCCCCCC>;
    struct
    {
        AnimGroupStruct AnimGroup[AnimGroupCount] <bgcolor=0xCCCCCC>;
    } AnimGroups;

    FSeek(Header.AnimDataOffset);
    struct
    {
        AnimDataStruct AnimData[Header.AnimDataCount] <optimize=false, bgcolor=0xCCCCCC>;
    } AnimData;
} Data;